<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Texas Instruments MSP432 Driver Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Texas Instruments MSP432 Driver Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p> 
<hr>
<h2> What DriverLib is </h2>
<hr>
 The Texas Instruments MSP432 Driver Library (DriverLib) is a set of fully functional APIs used to configure, control, and manipulate the hardware peripherals of the MSP432 platform. In addition to being able to control the MSP432 peripherals, DriverLib also gives the user the ability to use common ARM peripherals such as the Interrupt (NVIC) and Memory Protection Unit (MPU) as well as MSP430 peripherals such as the eUSCI Serial peripherals and Watchdog Timer (WDT).</p>
<p>DriverLib for MSP432 Series has been tested and compiled under a variety of different toolchains. Subsequently, for each toolchain a specific debugger was used for testing validation. Below is a list that contains the supported toolchain and corresponding hardware debugger used.</p>
<p> 
<table style="width: 473px; height: 134px;" border="1">
<tbody>
<tr>
<td style="font-weight: bold; text-decoration: underline;">Toolchain</td>
<td style="font-weight: bold; text-decoration: underline;">Debugger</td>
</tr>
<tr>
<td><a href="http://www.ti.com/tool/ccstudio" target="_blank">Texas Instruments Code Composer Studio 6.1</a>
&nbsp; </td>
<td>XDS110 (LaunchPad)</td>
</tr>
<tr>
<td><a target="_blank" href="http://www.iar.com/ewarm/">IAR Embedded Workbench for
ARM 7.30</a> </td>
<td>Segger J-LINK</td>
</tr>
<tr>
<td><a target="_blank" href="https://launchpad.net/gcc-arm-embedded">GNU C Compiler
4.8 (gcc)</a></td>
<td>Segger J-LINK<br>
</td>
</tr>
<tr>
<td><a href="http://www.keil.com/" target="_blank">Keil
Embedded Development Tools for ARM 5.14&nbsp;</a></td>
<td>KEIL U-Link Pro
</td>
</tr>
</tbody>
</table>
</p>
<p>The DriverLib is meant to provide a "software" layer to the programmer in order to facilitate higher level of programming compared to direct register accesses. Nearly every aspect of a MSP432 device can be configured and driven using the DriverLib APIs. By using the high level software APIs provided by DriverLib, users can create powerful and intuitive code which is highly portable between not only devices within the MSP432 platform, but between different families in the MSP430/MSP432 platforms.</p>
<p>Writing code in DriverLib will make user code more legible and easier to share among a group. For example, examine the following pair of code snippets. Both sets of code set MCLK to be sourced from VLO with a divider of four:</p>
<p><b>Traditional Register Access</b> </p><div class="fragment"><div class="line">CSKEY  =  0x695A;</div>
<div class="line">CSCTL1 |= SELM_1 | DIVM_2;</div>
<div class="line">CSKEY  =  0;</div>
</div><!-- fragment --><p><b>DriverLib Equivalent</b> </p><div class="fragment"><div class="line"><a class="code" href="group__cs__api.html#ga6622f298cfcbd65dd344a6ed12bb465b">CS_initClockSignal</a>(<a class="code" href="group__cs__api.html#gac0415638418987d05434bd1ef92cf5ca">CS_MCLK</a>, <a class="code" href="group__cs__api.html#ga4bdedd12f5fb40eb4d196c61ac7900bc">CS_VLOCLK_SELECT</a>, <a class="code" href="group__cs__api.html#gaaa2c86a4af1de1bb13e10f5ae855fd98">CS_CLOCK_DIVIDER_32</a>);</div>
</div><!-- fragment --><p>As can be seen, the DriverLib API is readable, sensible, and easy to program for the software engineer. Additionally, DriverLib APIs for other platforms such as MSP430 will use very similar (if not identical) APIs giving code written with DriverLib APIs a boost in portability.</p>
<p> 
<hr>
<h2> What DriverLib is not</h2>
<hr>
 The Driver Library is not meant to provide a layer of intelligence on the level of a user application. It is meant to be an aid to the programmer to be part of the larger solution- not the solution itself.</p>
<p>Interrupt handlers are also not included with the DriverLib APIs. APIs to manage/enable/disable interrupts are included, however the actual authoring of the interrupt service routine is left up to the programmer. For reference, A typical interrupt handler that takes advantage of DriverLib APIs can be seen in the following code snippet:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> port6_isr(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">   uint32_t status = <a class="code" href="group__gpio__api.html#gaae2434ab04c81df84b08afc9cba3ac2d">GPIO_getEnabledInterruptStatus</a>(<a class="code" href="group__gpio__api.html#ga4015edeeee8e09204bca45ff24af06db">GPIO_PORT_P6</a>);</div>
<div class="line"></div>
<div class="line">   <a class="code" href="group__gpio__api.html#ga353045e5b5f6cbd1ea2982ce9ec20fec">GPIO_clearInterruptFlag</a>(<a class="code" href="group__gpio__api.html#ga4015edeeee8e09204bca45ff24af06db">GPIO_PORT_P6</a>, status);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (status &amp; <a class="code" href="group__gpio__api.html#gad8c9677b2629cc4f2086e730df92208e">GPIO_PIN7</a>)</div>
<div class="line">   {</div>
<div class="line">       <span class="keywordflow">if</span> (powerStates[curPowerState] == <a class="code" href="group__pcm__api.html#ga0c93e352c74e674f2569e1754e277cb6">PCM_LPM3</a>)</div>
<div class="line">       {</div>
<div class="line">           curPowerState = 0;</div>
<div class="line">       }</div>
<div class="line">       stateChange = <span class="keyword">true</span>;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p> 
<hr>
<h2> Cross Module Considerations </h2>
<hr>
 Each DriverLib module will, for the most part, only interact and configure the module that it is designed for. Any cross-module interaction is left up to the user. For example, when changing power modes to a low frequency mode with the PCM module, the user will have to ensure that the proper frequency requirements are configured with the CS module (low frequency requires that the system frequency be no greater that 128Khz).</p>
<p>Calling the following API alone while MCLK is greater that 128Khz will result in a system error:</p>
<div class="fragment"><div class="line"><a class="code" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a>(<a class="code" href="group__pcm__api.html#ga631245b239dc783565fa972641560703">PCM_AM_LF_VCORE1</a>);</div>
</div><!-- fragment --><p>This is because the DriverLib module will not account for the overall system frequency of the system. Instead, similar APIs to the following must be called in conjunction:</p>
<div class="fragment"><div class="line"><a class="code" href="group__cs__api.html#gada16370f10e9354f04eff6b3a4ff3300">CS_setReferenceOscillatorFrequency</a>(<a class="code" href="group__cs__api.html#gaa1fddfed739224af9757cbe462762a9b">CS_REFO_128KHZ</a>);</div>
<div class="line"><a class="code" href="group__cs__api.html#ga6622f298cfcbd65dd344a6ed12bb465b">CS_initClockSignal</a>(<a class="code" href="group__cs__api.html#gac0415638418987d05434bd1ef92cf5ca">CS_MCLK</a>, <a class="code" href="group__cs__api.html#gad772a884e53d0fb1a806e3821c09ceaa">CS_REFOCLK_SELECT</a>, <a class="code" href="group__cs__api.html#ga48b6eb9e04335910b5dca814fe90a5e2">CS_CLOCK_DIVIDER_1</a>);</div>
<div class="line"><a class="code" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a>(<a class="code" href="group__pcm__api.html#ga631245b239dc783565fa972641560703">PCM_AM_LF_VCORE1</a>);</div>
</div><!-- fragment --><p>Cross-module considerations such as these must be taken when programming with DriverLib APIs as DriverLib was not designed to account for high level system requirements.</p>
  
<hr>
<h2> DriverLib in ROM </h2>
<hr>
 With all MSP432 devices, a copy of DriverLib is included within the device's ROM space. This allows programmers to take advantage of using high level APIs without having to worry about additional memory overhead of a flash library. In addition to a more optimized execution, the user can drastically cut down the memory footprint requirement of their application when using the software Driver Libraries available in ROM.</p>
<p>Accessing Driver Library APIs in ROM is as easy as including the <a class="el" href="rom_8h.html">rom.h</a> header file, and then replacing normal API calls with a <em>ROM_</em> prefix. For example, take the following API from the <a class="el" href="pcm_8c.html">pcm.c</a> module that changes the power state to PCM_AM_DCDC_VCORE1:</p>
<div class="fragment"><div class="line"><a class="code" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a>(<a class="code" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>);</div>
</div><!-- fragment --><p>After including the <a class="el" href="rom_8h.html">rom.h</a> file, all that would have to be done to switch to the ROM equivalent of the API would be add the ROM_ prefix to the API:</p>
<div class="fragment"><div class="line">ROM_PCM_setPowerState(<a class="code" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>);</div>
</div><!-- fragment --><p>While the majority of DriverLib APIs are available in ROM, due to architectural limitations some APIs are omitted from being included in ROM. In addition, if any bug fixes were added to the API after the device ROM was programmed, it is desirable to use the flash version of the API. An "intelligence" has been created to account for this problem. If the user includes the <a class="el" href="rom__map_8h.html">rom_map.h</a> header file and uses the <em>MAP_</em> prefix in front of the API, the header file will automatically use preprocessor macros to decide whether to use a ROM or flash version of the API.</p>
<div class="fragment"><div class="line"><a class="code" href="rom__map_8h.html#abcb62ff40409469fbc95fd896ff61ace">MAP_PCM_setPowerState</a>(<a class="code" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>);</div>
</div><!-- fragment --><p> 
<hr>
<h2> MSP430 Legacy APIs </h2>
<hr>
 Since the MSP432 platform is built with many modules from Texas Instruments' MSP430 platform, many shared modules exist between MSP430 and MSP432. For this reason, a "compatibility" layer is provided to provide between the MSP430 Driver Library and the MSP430 Driver Library. The following modules are shared between MSP432 and MSP430:</p>
<ul>
<li>AES256</li>
<li>COMP_E</li>
<li>CRC32</li>
<li>GPIO</li>
<li>EUSCI_A_SPI (SPI)</li>
<li>EUSCI_A_UART (UART)</li>
<li>EUSCI_B_I2C (I2C)</li>
<li>EUSCI_B_SPI (SPI)</li>
<li>PMAP</li>
<li>REF_A</li>
<li>RTC_C</li>
<li>TIMER_A</li>
<li>WDT_A</li>
</ul>
<p>To use these legacy APIs, no additional work is needed. All that is needed is to include the header file of the module you want to use and both the old and the new APIs will be available. For example, for WDT_A:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="wdt__a_8h.html">wdt_a.h</a>&gt;</span></div>
</div><!-- fragment --><p>By including this header file, the user is granted access to all of the legacy DriverLib APIs from MSP430 Driver Library verbatim. For additional documentation on the MSP430 implementation of DriverLib, please refer to the <a href="http://www.ti.com/tool/msp430ware">MSP430Ware Website</a>.</p>
<p>Many of the APIs were simplified and refactored for the MSP432 version of Driver Library. For example, to halt the watchdog module for a 5xx MSP430 device, the following API is used:</p>
<div class="fragment"><div class="line"><a class="code" href="group__wdt__api.html#gabb57bedb7bd61614a1bab23b31a51117">WDT_A_hold</a>(WDT_A_BASE);</div>
</div><!-- fragment -->  For MSP432 Driver Library, this same API has been simplified to the following API:</p>
<div class="fragment"><div class="line"><a class="code" href="group__wdt__api.html#ga67191ac5feea0b7285d8fc853effdfb6">WDT_A_holdTimer</a>();</div>
</div><!-- fragment --><p>Note that while many Driver Library APIs are shared between MSP430 and MSP432, there are a few underlying differences between the two architectures. Interrupts, for example, are a bit difference on MSP432 compared to MSP430 due to integration with ARM's interrupt controller (the NVIC). While each module will still have individual status (IFG), enable/disable, and clear bits, interrupt service routines now have to be associated with the ARM NVIC before usage.</p>
<p> 
<hr>
<h2> Quick Start </h2>
<hr>
</p>
<p>Getting started using DriverLib for MSP432 Series is very simple regardless of the chosen development environment.</p>
<p>An empty "skeleton" project is provided in the examples directory of the MSPWare release. This project includes links to the DriverLib library as well as everything that is needed for the programmer to immediately start writing a DriverLib application. A user can import this project in CCS using the TI Resource Explorer, or open the workspace with IAR Embedded Workbench for ARM or KEIL uVision 5. All of the include paths and compiler options are set up to allow the user to seamlessly start development on their MSP432 DriverLib application.</p>
<p>The GNU compiler tools for ARM are fully supported by the MSP432 Series DriverLib. While no IDE in specific is supported, Makefiles are provided for both the library and all of the code examples. Vector table definitions that are compatible with the GCC compiler are also provided for code examples in the startup_gcc.c file for each individual code example. For the GNU tools, separate header files are included in the inc directory of the root installation of DriverLib. These header files are the latest that are available at the time of DriverLib release, however newer header files may be downloaded as a part of the CCS installation. </p>
</div></div><!-- contents -->
<hr size="1" /><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
