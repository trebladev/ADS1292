<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PCM</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PCM</div>  </div>
</div><!--header-->
<div class="contents">

<p>Power Control Manager responsible for controlling the different power states of the device.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga99147e526657c3b835d9761759ff08ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga99147e526657c3b835d9761759ff08ea">PCM_KEY</a>&#160;&#160;&#160;0x695A0000</td></tr>
<tr class="separator:ga99147e526657c3b835d9761759ff08ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd62bbd1bded64bf60ce972b0f144b3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gafd62bbd1bded64bf60ce972b0f144b3e">PCM_AM_LDO_VCORE0</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gafd62bbd1bded64bf60ce972b0f144b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab61c30bfb8170df65b590dbc5f061822"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gab61c30bfb8170df65b590dbc5f061822">PCM_AM_LDO_VCORE1</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:gab61c30bfb8170df65b590dbc5f061822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1bfcae251c55b634bbedc1f282883e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf1bfcae251c55b634bbedc1f282883e8">PCM_AM_DCDC_VCORE0</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:gaf1bfcae251c55b634bbedc1f282883e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87365effd53591e5d2c82db3158465b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>&#160;&#160;&#160;0x05</td></tr>
<tr class="separator:gaf87365effd53591e5d2c82db3158465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30b98562b7f7070e203ac843e1b9fd4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gab30b98562b7f7070e203ac843e1b9fd4">PCM_AM_LF_VCORE0</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:gab30b98562b7f7070e203ac843e1b9fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga631245b239dc783565fa972641560703"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga631245b239dc783565fa972641560703">PCM_AM_LF_VCORE1</a>&#160;&#160;&#160;0x09</td></tr>
<tr class="separator:ga631245b239dc783565fa972641560703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace103e19fd988f59e70fec9b4e8bee29"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gace103e19fd988f59e70fec9b4e8bee29">PCM_LPM0_LDO_VCORE0</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:gace103e19fd988f59e70fec9b4e8bee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e450d3a5268052e2125da914f374aff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga8e450d3a5268052e2125da914f374aff">PCM_LPM0_LDO_VCORE1</a>&#160;&#160;&#160;0x11</td></tr>
<tr class="separator:ga8e450d3a5268052e2125da914f374aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a36b7673d1d8cbdfc00d26f6cc50b0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga6a36b7673d1d8cbdfc00d26f6cc50b0f">PCM_LPM0_DCDC_VCORE0</a>&#160;&#160;&#160;0x14</td></tr>
<tr class="separator:ga6a36b7673d1d8cbdfc00d26f6cc50b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe212fa6af57fb6581e20fce080c993"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga3fe212fa6af57fb6581e20fce080c993">PCM_LPM0_DCDC_VCORE1</a>&#160;&#160;&#160;0x15</td></tr>
<tr class="separator:ga3fe212fa6af57fb6581e20fce080c993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f66799f8d79113ea4e383d28bf5ca6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga21f66799f8d79113ea4e383d28bf5ca6">PCM_LPM0_LF_VCORE0</a>&#160;&#160;&#160;0x18</td></tr>
<tr class="separator:ga21f66799f8d79113ea4e383d28bf5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59adb6f58178d155bf493331283e9499"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga59adb6f58178d155bf493331283e9499">PCM_LPM0_LF_VCORE1</a>&#160;&#160;&#160;0x19</td></tr>
<tr class="separator:ga59adb6f58178d155bf493331283e9499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c93e352c74e674f2569e1754e277cb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga0c93e352c74e674f2569e1754e277cb6">PCM_LPM3</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ga0c93e352c74e674f2569e1754e277cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1c2db282057e4855736f1ec31d3d757"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gad1c2db282057e4855736f1ec31d3d757">PCM_LPM4</a>&#160;&#160;&#160;0x21</td></tr>
<tr class="separator:gad1c2db282057e4855736f1ec31d3d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a099284de8385beb04f10438695bea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gae9a099284de8385beb04f10438695bea">PCM_LPM35_VCORE0</a>&#160;&#160;&#160;0xC0</td></tr>
<tr class="separator:gae9a099284de8385beb04f10438695bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3369099804e8ec1bfbdb396fbdab5f3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gae3369099804e8ec1bfbdb396fbdab5f3">PCM_LPM45</a>&#160;&#160;&#160;0xA0</td></tr>
<tr class="separator:gae3369099804e8ec1bfbdb396fbdab5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae399b099eb6bc8f0b0836677e985e62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaae399b099eb6bc8f0b0836677e985e62">PCM_VCORE0</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gaae399b099eb6bc8f0b0836677e985e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8248d84a15fa854397b2516e2e3e5290"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga8248d84a15fa854397b2516e2e3e5290">PCM_VCORE1</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga8248d84a15fa854397b2516e2e3e5290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae255c6c491cf335b0c3a9777b3f7a254"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gae255c6c491cf335b0c3a9777b3f7a254">PCM_VCORELPM3</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gae255c6c491cf335b0c3a9777b3f7a254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea3880d9ab27db9004ac4f9b991c2c1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaea3880d9ab27db9004ac4f9b991c2c1f">PCM_LDO_MODE</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:gaea3880d9ab27db9004ac4f9b991c2c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2110b687d5cef1fae56323db2f747795"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2110b687d5cef1fae56323db2f747795">PCM_DCDC_MODE</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ga2110b687d5cef1fae56323db2f747795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac177f4b7ecfce7200a95b5a6bacbf89a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gac177f4b7ecfce7200a95b5a6bacbf89a">PCM_LF_MODE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:gac177f4b7ecfce7200a95b5a6bacbf89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1536275cd1b086070caf9219948ebada"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga1536275cd1b086070caf9219948ebada">PCM_SHUTDOWN_PARTIAL</a>&#160;&#160;&#160;<a class="el" href="group__pcm__api.html#gae9a099284de8385beb04f10438695bea">PCM_LPM35_VCORE0</a></td></tr>
<tr class="separator:ga1536275cd1b086070caf9219948ebada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac091b7ed755f0e16ddeba7d07b79c082"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gac091b7ed755f0e16ddeba7d07b79c082">PCM_SHUTDOWN_COMPLETE</a>&#160;&#160;&#160;<a class="el" href="group__pcm__api.html#gae3369099804e8ec1bfbdb396fbdab5f3">PCM_LPM45</a></td></tr>
<tr class="separator:gac091b7ed755f0e16ddeba7d07b79c082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8ff7c7449e8317f4ff3865d2b9ab52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga0c8ff7c7449e8317f4ff3865d2b9ab52">PCM_DCDCERROR</a>&#160;&#160;&#160;PCM_IE_DCDC_ERROR_IE</td></tr>
<tr class="separator:ga0c8ff7c7449e8317f4ff3865d2b9ab52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60f62051eeb1722ed3ac4dfcad18ab75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga60f62051eeb1722ed3ac4dfcad18ab75">PCM_AM_INVALIDTRANSITION</a>&#160;&#160;&#160;PCM_IE_AM_INVALID_TR_IE</td></tr>
<tr class="separator:ga60f62051eeb1722ed3ac4dfcad18ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a1fc50fe6e5e404cf856acb67ef564"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaa9a1fc50fe6e5e404cf856acb67ef564">PCM_SM_INVALIDCLOCK</a>&#160;&#160;&#160;PCM_IE_LPM_INVALID_CLK_IE</td></tr>
<tr class="separator:gaa9a1fc50fe6e5e404cf856acb67ef564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7430605713d765d35c44b988d6ab468f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga7430605713d765d35c44b988d6ab468f">PCM_SM_INVALIDTRANSITION</a>&#160;&#160;&#160;PCM_IE_LPM_INVALID_TR_IE</td></tr>
<tr class="separator:ga7430605713d765d35c44b988d6ab468f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaadb3d2e085a27d5e2cebe84196533fe3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaadb3d2e085a27d5e2cebe84196533fe3">PCM_setCoreVoltageLevel</a> (uint_fast8_t voltageLevel)</td></tr>
<tr class="separator:gaadb3d2e085a27d5e2cebe84196533fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e55a8228de10311eacbdb0bde780ac4"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel</a> (void)</td></tr>
<tr class="separator:ga1e55a8228de10311eacbdb0bde780ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc18be0c36ea2be20b7d108543b1f8eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gabc18be0c36ea2be20b7d108543b1f8eb">PCM_setCoreVoltageLevelWithTimeout</a> (uint_fast8_t voltageLevel, uint32_t timeOut)</td></tr>
<tr class="separator:gabc18be0c36ea2be20b7d108543b1f8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f3a6d5eaef8339d3242f9cb0120adc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga7f3a6d5eaef8339d3242f9cb0120adc8">PCM_setCoreVoltageLevelNonBlocking</a> (uint_fast8_t voltageLevel)</td></tr>
<tr class="separator:ga7f3a6d5eaef8339d3242f9cb0120adc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bbba40f896f89b792b78f4b54b0078d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga5bbba40f896f89b792b78f4b54b0078d">PCM_setPowerMode</a> (uint_fast8_t powerMode)</td></tr>
<tr class="separator:ga5bbba40f896f89b792b78f4b54b0078d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78385c4c1a29ba989a995eef9d0bf4b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga78385c4c1a29ba989a995eef9d0bf4b3">PCM_setPowerModeWithTimeout</a> (uint_fast8_t powerMode, uint32_t timeOut)</td></tr>
<tr class="separator:ga78385c4c1a29ba989a995eef9d0bf4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9265c253e2ef1d848edf31ad200ad94a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga9265c253e2ef1d848edf31ad200ad94a">PCM_setPowerModeNonBlocking</a> (uint_fast8_t powerMode)</td></tr>
<tr class="separator:ga9265c253e2ef1d848edf31ad200ad94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98797f17f6b52e66b8eb42b86f0c2e1d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode</a> (void)</td></tr>
<tr class="separator:ga98797f17f6b52e66b8eb42b86f0c2e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfe9e81af9f912ad010dea02a84e1dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a> (uint_fast8_t powerState)</td></tr>
<tr class="separator:gadcfe9e81af9f912ad010dea02a84e1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga013ca7d7d9540e55ccce332ddac37c3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga013ca7d7d9540e55ccce332ddac37c3a">PCM_setPowerStateWithTimeout</a> (uint_fast8_t powerState, uint32_t timeout)</td></tr>
<tr class="separator:ga013ca7d7d9540e55ccce332ddac37c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fd3e28f2cf736397d7849b13e29e086"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga0fd3e28f2cf736397d7849b13e29e086">PCM_getPowerState</a> (void)</td></tr>
<tr class="separator:ga0fd3e28f2cf736397d7849b13e29e086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e54ae81e8ba5c30fabd3c126a5eda0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2e54ae81e8ba5c30fabd3c126a5eda0a">PCM_setPowerStateNonBlocking</a> (uint_fast8_t powerState)</td></tr>
<tr class="separator:ga2e54ae81e8ba5c30fabd3c126a5eda0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8a4f38b56ffdfa166f74de92b64ea08"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf8a4f38b56ffdfa166f74de92b64ea08">PCM_shutdownDevice</a> (uint32_t shutdownMode)</td></tr>
<tr class="separator:gaf8a4f38b56ffdfa166f74de92b64ea08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe310d00db05c52931b714da4c11b7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaffe310d00db05c52931b714da4c11b7d">PCM_gotoLPM0</a> (void)</td></tr>
<tr class="separator:gaffe310d00db05c52931b714da4c11b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga629a4ca61ca8813a231250057d426885"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3</a> (void)</td></tr>
<tr class="separator:ga629a4ca61ca8813a231250057d426885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d3320b552e378c333c37fad34517a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf1d3320b552e378c333c37fad34517a3">PCM_gotoLPM0InterruptSafe</a> (void)</td></tr>
<tr class="separator:gaf1d3320b552e378c333c37fad34517a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf9fd4192110e273db7648dae87de3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga3bf9fd4192110e273db7648dae87de3d">PCM_gotoLPM3InterruptSafe</a> (void)</td></tr>
<tr class="separator:ga3bf9fd4192110e273db7648dae87de3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8029aa4c1db3892bbe3e93af840b31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gacd8029aa4c1db3892bbe3e93af840b31">PCM_gotoLPM4</a> (void)</td></tr>
<tr class="separator:gacd8029aa4c1db3892bbe3e93af840b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e450f968451a50c570baa972e37250a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2e450f968451a50c570baa972e37250a">PCM_gotoLPM4InterruptSafe</a> (void)</td></tr>
<tr class="separator:ga2e450f968451a50c570baa972e37250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4787884be1ce9ed19008fad506d3036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaf4787884be1ce9ed19008fad506d3036">PCM_enableRudeMode</a> (void)</td></tr>
<tr class="separator:gaf4787884be1ce9ed19008fad506d3036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022c681cdc82a9a729d4c6491fa04fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga022c681cdc82a9a729d4c6491fa04fdd">PCM_disableRudeMode</a> (void)</td></tr>
<tr class="separator:ga022c681cdc82a9a729d4c6491fa04fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa13b8e1cdcad429be17abf93ef32b55e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#gaa13b8e1cdcad429be17abf93ef32b55e">PCM_enableInterrupt</a> (uint32_t flags)</td></tr>
<tr class="separator:gaa13b8e1cdcad429be17abf93ef32b55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57c6fa2c61a09135ec4ad2467b465ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga57c6fa2c61a09135ec4ad2467b465ac2">PCM_disableInterrupt</a> (uint32_t flags)</td></tr>
<tr class="separator:ga57c6fa2c61a09135ec4ad2467b465ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13480f488469c23521b1c583c6869b37"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga13480f488469c23521b1c583c6869b37">PCM_getInterruptStatus</a> (void)</td></tr>
<tr class="separator:ga13480f488469c23521b1c583c6869b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e666dad597a14a2ed14220bf1045862"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga2e666dad597a14a2ed14220bf1045862">PCM_getEnabledInterruptStatus</a> (void)</td></tr>
<tr class="separator:ga2e666dad597a14a2ed14220bf1045862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63181a0fc0044f9db7e5666706a51b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga63181a0fc0044f9db7e5666706a51b4d">PCM_clearInterruptFlag</a> (uint32_t flags)</td></tr>
<tr class="separator:ga63181a0fc0044f9db7e5666706a51b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9994d27c2640ad8f86173f0ec36a383d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga9994d27c2640ad8f86173f0ec36a383d">PCM_registerInterrupt</a> (void(*intHandler)(void))</td></tr>
<tr class="separator:ga9994d27c2640ad8f86173f0ec36a383d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a6b73614bd5c9fe03650563624ffcc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcm__api.html#ga8a6b73614bd5c9fe03650563624ffcc1">PCM_unregisterInterrupt</a> (void)</td></tr>
<tr class="separator:ga8a6b73614bd5c9fe03650563624ffcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Power Control Manager responsible for controlling the different power states of the device. </p>
<p> 
<hr>
<h1> PCM Module Operation </h1>
<hr>
 The Power Control Manager (PCM) module for DriverLib is meant to simplify the management of power states and provide a level of intelligence to users for switching between power states.</p>
<p> 
<hr>
<h2>Switching States</h2>
<hr>
 One of the most useful features of the PCM module is the ability for the user to switch between power states without having to worry about the logic requirements of the state transitions. By using the PCM_setPowerState function, DriverLib will take in a parameter for the power state and automatically handle all of the state transitions. Say that the user wants to switch to use the DCDC converter with a voltage level of VCORE1 (PCM_AM_DCDC_VCORE1). Say that that same user is currently in the default mode of using the LDO with a voltage level of VCORE0 (PCM_AM_LDO_VCORE0). Normally, the user would have to take into account that there is a state transition that must happen to PCM_AM_LDO_VCORE1, however with the PCM_setPowerState API the user does not need to worry about this. The call to change the power state in this example would be: </p><div class="fragment"><div class="line"><a class="code" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a>(<a class="code" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>);</div>
</div><!-- fragment --><p> 
<hr>
<h2>Switching Modes/Levels</h2>
<hr>
 In addition to being able to switch between individual power states, the PCM DriverLib API module also gives the user the ability to switch between different power modes and levels. This gives the user a more granular approach to power management and allows for a more refined customization of the power driver.</p>
<p>For changing between power levels, the user will be able to switch back and forth between <b>PCM_VCORE0</b> and <b>PCM_VCORE1</b> using the PCM_setCoreVoltageLevel function. While using this function it is important to note that the underlying power mode will be preserved. For example, if PCM_setCoreVoltageLevel is called with the <b>PCM_VCORE1</b> parameter while the devices is in <b>PCM_AM_LDO_VCORE0</b> mode, the power state will be changed to <b>PCM_AM_LDO_VCORE1</b>. If the same API is called with the same parameter in <b>PCM_AM_DCDC_VCORE0</b> mode, the power state will be changed to <b>PCM_AM_DCDC_VCORE1</b> mode.</p>
<p>The same preservation logic also applies while switching between power modes. If the PCM_setPowerMode function is called with the <b>PCM_DCDC_MODE</b> parameter while the device is in <b>PCM_AM_LDO_VCORE0</b> mode, the device will change to <b>PCM_AM_DCDC_VCORE0</b> mode (leaving the voltage level unchanged).</p>
<p> 
<hr>
<h2>Low Power Mode and State Retention</h2>
<hr>
 In addition to being able to manipulate individual states/modes/levels, APIs are also provided to simplify entry into the low power modes of MSP432.</p>
<p><b>Low Power Entry Functions:</b> </p><ul>
<li>
PCM_gotoLPM0 </li>
<li>
PCM_gotoLPM3 </li>
<li>
PCM_shutdownDevice </li>
</ul>
<p>When using these low power modes entry functions, it is important to note that the original state of the device before low power mode entry is retained. After the devices wakes up from low power mode, the original power mode is restored. For example, say that the device is in <b>PCM_AM_DCDC_VCORE0</b> mode and then the user calls the PCM_gotoLPM3 API. Since MSP432 devices are not allowed to go into LMP3 while in a DCDC power mode, the API will have the intelligence to first change into <b>PCM_AM_LDO_VCORE0</b> mode, and then go to LPM3. When the device wakes up, the API will automatically switch back to <b>PCM_AM_DCDC_VCORE0</b> mode. If the user wants to go into DSL in the previous example without the state preservation, the PCM_setPowerState function should be used with the <b>PCM_LPM3</b> parameter.</p>
<p> 
<hr>
<h2>Enabling/Disabling Rude Mode</h2>
<hr>
 If the user calls a low power entry function that disables a clock source while an active peripheral is accessing the clock source, by default MSP432 will not allow the transition. This can be enabled/disabled by using the PCM_enableRudeMode and PCM_disableRudeMode functions respectively. By using these functions, the user can set the device to "force" its way into the low power mode by forcibly halting any dependent clock resource.   
<hr>
<h2>Programming Examples</h2>
<hr>
 The DriverLib package contains a variety of different code examples that demonstrate the usage of the PCM module. These code examples are accessible under the examples/ folder of the MSPWare release as well as through TI Resource Explorer if using Code Composer Studio. These code examples provide a comprehensive list of use cases as well as practical applications involving each module.</p>
<p>Below is a very brief code example showing how to change power levels with the PCM module. This is done in order to facilitate a higher frequency of 48Mhz. For a set of more detailed code examples, please refer to the code examples in the examples/ directory of the MSPWare release:</p>
<div class="fragment"><div class="line">            <span class="comment">/* Re-enabling port pin interrupt */</span></div>
<div class="line">            <a class="code" href="rom__map_8h.html#a70b27625d14c96719ce24dfaa89477ec">MAP_GPIO_clearInterruptFlag</a>(<a class="code" href="group__gpio__api.html#gad67126281df81dd043cc5a51127d2002">GPIO_PORT_P1</a>, <a class="code" href="group__gpio__api.html#ga2dc81f879c206e185859e16a1d183d20">GPIO_PIN1</a>);</div>
<div class="line">            <a class="code" href="rom__map_8h.html#a44e61c3aaa6345b682bdb6a668837d26">MAP_Interrupt_enableInterrupt</a>(<a class="code" href="group__interrupt__api.html#gab84638119914f2ee5bf88193c52f3521">INT_PORT1</a>);</div>
<div class="line">            <a class="code" href="rom__map_8h.html#a92dae96b189e5887d69318a9695fc7d7">MAP_Interrupt_enableMaster</a>();</div>
<div class="line"></div>
<div class="line">            <span class="comment">/* Change to new power state */</span></div>
<div class="line">            <a class="code" href="rom__map_8h.html#abcb62ff40409469fbc95fd896ff61ace">MAP_PCM_setPowerState</a>(powerStates[curPowerState]);</div>
</div><!-- fragment --><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga99147e526657c3b835d9761759ff08ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_KEY&#160;&#160;&#160;0x695A0000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga022c681cdc82a9a729d4c6491fa04fdd">PCM_disableRudeMode()</a>, <a class="el" href="group__pcm__api.html#gaf4787884be1ce9ed19008fad506d3036">PCM_enableRudeMode()</a>, <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>, and <a class="el" href="group__pcm__api.html#gaf8a4f38b56ffdfa166f74de92b64ea08">PCM_shutdownDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="gafd62bbd1bded64bf60ce972b0f144b3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_LDO_VCORE0&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gab61c30bfb8170df65b590dbc5f061822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_LDO_VCORE1&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1bfcae251c55b634bbedc1f282883e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_DCDC_VCORE0&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf87365effd53591e5d2c82db3158465b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_DCDC_VCORE1&#160;&#160;&#160;0x05</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gab30b98562b7f7070e203ac843e1b9fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_LF_VCORE0&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga631245b239dc783565fa972641560703"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_LF_VCORE1&#160;&#160;&#160;0x09</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="gace103e19fd988f59e70fec9b4e8bee29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM0_LDO_VCORE0&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8e450d3a5268052e2125da914f374aff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM0_LDO_VCORE1&#160;&#160;&#160;0x11</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6a36b7673d1d8cbdfc00d26f6cc50b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM0_DCDC_VCORE0&#160;&#160;&#160;0x14</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3fe212fa6af57fb6581e20fce080c993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM0_DCDC_VCORE1&#160;&#160;&#160;0x15</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga21f66799f8d79113ea4e383d28bf5ca6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM0_LF_VCORE0&#160;&#160;&#160;0x18</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga59adb6f58178d155bf493331283e9499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM0_LF_VCORE1&#160;&#160;&#160;0x19</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, and <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c93e352c74e674f2569e1754e277cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM3&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="gad1c2db282057e4855736f1ec31d3d757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM4&#160;&#160;&#160;0x21</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae9a099284de8385beb04f10438695bea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM35_VCORE0&#160;&#160;&#160;0xC0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gae3369099804e8ec1bfbdb396fbdab5f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LPM45&#160;&#160;&#160;0xA0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#gaf8a4f38b56ffdfa166f74de92b64ea08">PCM_shutdownDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="gaae399b099eb6bc8f0b0836677e985e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_VCORE0&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8248d84a15fa854397b2516e2e3e5290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_VCORE1&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="gae255c6c491cf335b0c3a9777b3f7a254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_VCORELPM3&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>.</p>

</div>
</div>
<a class="anchor" id="gaea3880d9ab27db9004ac4f9b991c2c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LDO_MODE&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>, and <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2110b687d5cef1fae56323db2f747795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_DCDC_MODE&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>, and <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="gac177f4b7ecfce7200a95b5a6bacbf89a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_LF_MODE&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>, and <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1536275cd1b086070caf9219948ebada"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_SHUTDOWN_PARTIAL&#160;&#160;&#160;<a class="el" href="group__pcm__api.html#gae9a099284de8385beb04f10438695bea">PCM_LPM35_VCORE0</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#gaf8a4f38b56ffdfa166f74de92b64ea08">PCM_shutdownDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="gac091b7ed755f0e16ddeba7d07b79c082"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_SHUTDOWN_COMPLETE&#160;&#160;&#160;<a class="el" href="group__pcm__api.html#gae3369099804e8ec1bfbdb396fbdab5f3">PCM_LPM45</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="group__pcm__api.html#gaf8a4f38b56ffdfa166f74de92b64ea08">PCM_shutdownDevice()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c8ff7c7449e8317f4ff3865d2b9ab52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_DCDCERROR&#160;&#160;&#160;PCM_IE_DCDC_ERROR_IE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga60f62051eeb1722ed3ac4dfcad18ab75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_AM_INVALIDTRANSITION&#160;&#160;&#160;PCM_IE_AM_INVALID_TR_IE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa9a1fc50fe6e5e404cf856acb67ef564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_SM_INVALIDCLOCK&#160;&#160;&#160;PCM_IE_LPM_INVALID_CLK_IE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7430605713d765d35c44b988d6ab468f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PCM_SM_INVALIDTRANSITION&#160;&#160;&#160;PCM_IE_LPM_INVALID_TR_IE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaadb3d2e085a27d5e2cebe84196533fe3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setCoreVoltageLevel </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>voltageLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). The function will take care of all power state transitions needed to shift between core voltage levels. Because transitions between voltage levels may require changes power modes, the power mode might temporarily be change. The power mode will be returned to the original state (with the new voltage level) at the end of a successful execution of this function.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltageLevel</td><td>The voltage level to be shifted to.<ul>
<li><b>PCM_VCORE0</b>,</li>
<li><b>PCM_VCORE1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voltage level set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e55a8228de10311eacbdb0bde780ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PCM_getCoreVoltageLevel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current powers state of the system see the PCM_setCoreVoltageLevel function for specific information about the modes.</p>
<dl class="section return"><dt>Returns</dt><dd>The current voltage of the system</dd></dl>
<p>Possible return values include:</p><ul>
<li><b>PCM_VCORE0</b> </li>
<li><b>PCM_VCORE1</b> </li>
<li><b>PCM_VCORELPM3</b> </li>
</ul>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="group__pcm__api.html#gaf1bfcae251c55b634bbedc1f282883e8">PCM_AM_DCDC_VCORE0</a>, <a class="el" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>, <a class="el" href="group__pcm__api.html#gafd62bbd1bded64bf60ce972b0f144b3e">PCM_AM_LDO_VCORE0</a>, <a class="el" href="group__pcm__api.html#gab61c30bfb8170df65b590dbc5f061822">PCM_AM_LDO_VCORE1</a>, <a class="el" href="group__pcm__api.html#gab30b98562b7f7070e203ac843e1b9fd4">PCM_AM_LF_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga631245b239dc783565fa972641560703">PCM_AM_LF_VCORE1</a>, <a class="el" href="group__pcm__api.html#ga0fd3e28f2cf736397d7849b13e29e086">PCM_getPowerState()</a>, <a class="el" href="group__pcm__api.html#ga6a36b7673d1d8cbdfc00d26f6cc50b0f">PCM_LPM0_DCDC_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga3fe212fa6af57fb6581e20fce080c993">PCM_LPM0_DCDC_VCORE1</a>, <a class="el" href="group__pcm__api.html#gace103e19fd988f59e70fec9b4e8bee29">PCM_LPM0_LDO_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga8e450d3a5268052e2125da914f374aff">PCM_LPM0_LDO_VCORE1</a>, <a class="el" href="group__pcm__api.html#ga21f66799f8d79113ea4e383d28bf5ca6">PCM_LPM0_LF_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga59adb6f58178d155bf493331283e9499">PCM_LPM0_LF_VCORE1</a>, <a class="el" href="group__pcm__api.html#ga0c93e352c74e674f2569e1754e277cb6">PCM_LPM3</a>, <a class="el" href="group__pcm__api.html#gaae399b099eb6bc8f0b0836677e985e62">PCM_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga8248d84a15fa854397b2516e2e3e5290">PCM_VCORE1</a>, and <a class="el" href="group__pcm__api.html#gae255c6c491cf335b0c3a9777b3f7a254">PCM_VCORELPM3</a>.</p>

</div>
</div>
<a class="anchor" id="gabc18be0c36ea2be20b7d108543b1f8eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setCoreVoltageLevelWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>voltageLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). This function will take care of all power state transitions needed to shift between core voltage levels. Because transitions between voltage levels may require changes power modes, the power mode might temporarily be change. The power mode will be returned to the original state (with the new voltage level) at the end of a successful execution of this function.</p>
<p>This function is similar to PCMSetCoreVoltageLevel, however a timeout mechanism is used.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltageLevel</td><td>The voltage level to be shifted to.<ul>
<li><b>PCM_VCORE0</b>,</li>
<li><b>PCM_VCORE1</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">timeOut</td><td>Number of loop iterations to timeout when checking for power state transitions. This should be used for debugging initial power/hardware configurations. After a stable hardware base is established, the PCMSetCoreVoltageLevel function should be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voltage level set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7f3a6d5eaef8339d3242f9cb0120adc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setCoreVoltageLevelNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>voltageLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). This function is similar to PCM_setCoreVoltageLevel, however there are no polling flags to ensure a state has changed. Execution is returned back to the calling program correctly. For MSP432, changing into different power modes/states require very specific logic. This function will initiate only one state transition and then return. It is up to the user to keep calling this function until the correct power state has been achieved.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">voltageLevel</td><td>The voltage level to be shifted to.<ul>
<li><b>PCM_VCORE0</b>,</li>
<li><b>PCM_VCORE1</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if voltage level set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5bbba40f896f89b792b78f4b54b0078d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerMode </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power modes. This function will take care of all power state transitions needed to shift between power modes. Note for changing to DCDC mode, specific hardware considerations are required.</p>
<p>Refer to the device specific data sheet for specifics about power modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerMode</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_LDO_MODE</b>,</li>
<li><b>PCM_DCDC_MODE</b>,</li>
<li><b>PCM_LF_MODE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power mode is set, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78385c4c1a29ba989a995eef9d0bf4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerModeWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power modes. This function will take care of all power state transitions needed to shift between power modes. Note for changing to DCDC mode, specific hardware considerations are required.</p>
<p>This function is similar to PCMSetPowerMode, however a timeout mechanism is used.</p>
<p>Refer to the device specific data sheet for specifics about power modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerMode</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_LDO_MODE</b>,</li>
<li><b>PCM_DCDC_MODE</b>,</li>
<li><b>PCM_LF_MODE</b> </li>
</ul>
</td></tr>
    <tr><td class="paramname">timeOut</td><td>Number of loop iterations to timeout when checking for power state transitions. This should be used for debugging initial power/hardware configurations. After a stable hardware base is established, the PCMSetPowerMode function should be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power mode is set, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9265c253e2ef1d848edf31ad200ad94a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerModeNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the core voltage level (Vcore). This function is similar to PCM_setPowerMode, however there are no polling flags to ensure a state has changed. Execution is returned back to the calling program correctly. For MSP432, changing into different power modes/states require very specific logic. This function will initiate only one state transition and then return. It is up to the user to keep calling this function until the correct power state has been achieved.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerMode</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_LDO_MODE</b>,</li>
<li><b>PCM_DCDC_MODE</b>,</li>
<li><b>PCM_LF_MODE</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power mode change was initiated, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga98797f17f6b52e66b8eb42b86f0c2e1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PCM_getPowerMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current powers state of the system see the <b>PCM_setPowerState</b> function for specific information about the modes.</p>
<dl class="section return"><dt>Returns</dt><dd>The current power mode of the system </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="group__pcm__api.html#gaf1bfcae251c55b634bbedc1f282883e8">PCM_AM_DCDC_VCORE0</a>, <a class="el" href="group__pcm__api.html#gaf87365effd53591e5d2c82db3158465b">PCM_AM_DCDC_VCORE1</a>, <a class="el" href="group__pcm__api.html#gafd62bbd1bded64bf60ce972b0f144b3e">PCM_AM_LDO_VCORE0</a>, <a class="el" href="group__pcm__api.html#gab61c30bfb8170df65b590dbc5f061822">PCM_AM_LDO_VCORE1</a>, <a class="el" href="group__pcm__api.html#gab30b98562b7f7070e203ac843e1b9fd4">PCM_AM_LF_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga631245b239dc783565fa972641560703">PCM_AM_LF_VCORE1</a>, <a class="el" href="group__pcm__api.html#ga2110b687d5cef1fae56323db2f747795">PCM_DCDC_MODE</a>, <a class="el" href="group__pcm__api.html#ga0fd3e28f2cf736397d7849b13e29e086">PCM_getPowerState()</a>, <a class="el" href="group__pcm__api.html#gaea3880d9ab27db9004ac4f9b991c2c1f">PCM_LDO_MODE</a>, <a class="el" href="group__pcm__api.html#gac177f4b7ecfce7200a95b5a6bacbf89a">PCM_LF_MODE</a>, <a class="el" href="group__pcm__api.html#ga6a36b7673d1d8cbdfc00d26f6cc50b0f">PCM_LPM0_DCDC_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga3fe212fa6af57fb6581e20fce080c993">PCM_LPM0_DCDC_VCORE1</a>, <a class="el" href="group__pcm__api.html#gace103e19fd988f59e70fec9b4e8bee29">PCM_LPM0_LDO_VCORE0</a>, <a class="el" href="group__pcm__api.html#ga8e450d3a5268052e2125da914f374aff">PCM_LPM0_LDO_VCORE1</a>, <a class="el" href="group__pcm__api.html#ga21f66799f8d79113ea4e383d28bf5ca6">PCM_LPM0_LF_VCORE0</a>, and <a class="el" href="group__pcm__api.html#ga59adb6f58178d155bf493331283e9499">PCM_LPM0_LF_VCORE1</a>.</p>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="gadcfe9e81af9f912ad010dea02a84e1dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerState </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power states. This is a convenience function that combines the functionality of PCM_setPowerMode and PCM_setCoreVoltageLevel as well as the LPM0/LPM3 functions.</p>
<p>Refer to the device specific data sheet for specifics about power states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerState</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_AM_LDO_VCORE0</b>, [Active Mode, LDO, VCORE0]</li>
<li><b>PCM_AM_LDO_VCORE1</b>, [Active Mode, LDO, VCORE1]</li>
<li><b>PCM_AM_DCDC_VCORE0</b>, [Active Mode, DCDC, VCORE0]</li>
<li><b>PCM_AM_DCDC_VCORE1</b>, [Active Mode, DCDC, VCORE1]</li>
<li><b>PCM_AM_LF_VCORE0</b>, [Active Mode, Low Frequency, VCORE0]</li>
<li><b>PCM_AM_LF_VCORE1</b>, [Active Mode, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM0_LDO_VCORE0</b>, [LMP0, LDO, VCORE0]</li>
<li><b>PCM_LPM0_LDO_VCORE1</b>, [LMP0, LDO, VCORE1]</li>
<li><b>PCM_LPM0_DCDC_VCORE0</b>, [LMP0, DCDC, VCORE0]</li>
<li><b>PCM_LPM0_DCDC_VCORE1</b>, [LMP0, DCDC, VCORE1]</li>
<li><b>PCM_LPM0_LF_VCORE0</b>, [LMP0, Low Frequency, VCORE0]</li>
<li><b>PCM_LPM0_LF_VCORE1</b>, [LMP0, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM3</b>, [LPM3]</li>
<li><b>PCM_LPM35_VCORE0</b>, [LPM3.5 VCORE 0]</li>
<li><b>PCM_LPM4</b>, [LPM4]</li>
<li><b>PCM_LPM45</b>, [LPM4.5]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power state is set, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="ga013ca7d7d9540e55ccce332ddac37c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerStateWithTimeout </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switches between power states. This is a convenience function that combines the functionality of PCM_setPowerMode and PCM_setCoreVoltageLevel as well as the LPM modes.</p>
<p>This function is similar to PCM_setPowerState, however a timeout mechanism is used.</p>
<p>Refer to the device specific data sheet for specifics about power states.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerState</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_AM_LDO_VCORE0</b>, [Active Mode, LDO, VCORE0]</li>
<li><b>PCM_AM_LDO_VCORE1</b>, [Active Mode, LDO, VCORE1]</li>
<li><b>PCM_AM_DCDC_VCORE0</b>, [Active Mode, DCDC, VCORE0]</li>
<li><b>PCM_AM_DCDC_VCORE1</b>, [Active Mode, DCDC, VCORE1]</li>
<li><b>PCM_AM_LF_VCORE0</b>, [Active Mode, Low Frequency, VCORE0]</li>
<li><b>PCM_AM_LF_VCORE1</b>, [Active Mode, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM0_LDO_VCORE0</b>, [LMP0, LDO, VCORE0]</li>
<li><b>PCM_LPM0_LDO_VCORE1</b>, [LMP0, LDO, VCORE1]</li>
<li><b>PCM_LPM0_DCDC_VCORE0</b>, [LMP0, DCDC, VCORE0]</li>
<li><b>PCM_LPM0_DCDC_VCORE1</b>, [LMP0, DCDC, VCORE1]</li>
<li><b>PCM_LPM0_LF_VCORE0</b>, [LMP0, Low Frequency, VCORE0]</li>
<li><b>PCM_LPM0_LF_VCORE1</b>, [LMP0, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM3</b>, [LPM3]</li>
<li><b>PCM_LPM35_VCORE0</b>, [LPM3.5 VCORE 0]</li>
<li><b>PCM_LPM4</b>, [LPM4]</li>
<li><b>PCM_LPM45</b>, [LPM4.5]</li>
</ul>
</td></tr>
    <tr><td class="paramname">timeout</td><td>Number of loop iterations to timeout when checking for power state transitions. This should be used for debugging initial power/hardware configurations. After a stable hardware base is established, the PCMSetPowerMode function should be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power state is set, false otherwise. It is important to note that if a timeout occurs, false will be returned, however the power state at this point is not guaranteed to be the same as the state prior to the function call </dd></dl>

</div>
</div>
<a class="anchor" id="ga0fd3e28f2cf736397d7849b13e29e086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t PCM_getPowerState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current powers state of the system see the PCMChangePowerState function for specific information about the states.</p>
<p>Refer to <a class="el" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState</a> for possible return values.</p>
<dl class="section return"><dt>Returns</dt><dd>The current power state of the system </dd></dl>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga1e55a8228de10311eacbdb0bde780ac4">PCM_getCoreVoltageLevel()</a>, <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>, and <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e54ae81e8ba5c30fabd3c126a5eda0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_setPowerStateNonBlocking </td>
          <td>(</td>
          <td class="paramtype">uint_fast8_t&#160;</td>
          <td class="paramname"><em>powerState</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the power state of the part. This function is similar to PCM_getPowerState, however there are no polling flags to ensure a state has changed. Execution is returned back to the calling program correctly. For MSP432, changing into different power modes/states require very specific logic. This function will initiate only one state transition and then return. It is up to the user to keep calling this function until the correct power state has been achieved.</p>
<p>Refer to the device specific data sheet for specifics about core voltage levels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">powerState</td><td>The voltage modes to be shifted to. Valid values are:<ul>
<li><b>PCM_AM_LDO_VCORE0</b>, [Active Mode, LDO, VCORE0]</li>
<li><b>PCM_AM_LDO_VCORE1</b>, [Active Mode, LDO, VCORE1]</li>
<li><b>PCM_AM_DCDC_VCORE0</b>, [Active Mode, DCDC, VCORE0]</li>
<li><b>PCM_AM_DCDC_VCORE1</b>, [Active Mode, DCDC, VCORE1]</li>
<li><b>PCM_AM_LF_VCORE0</b>, [Active Mode, Low Frequency, VCORE0]</li>
<li><b>PCM_AM_LF_VCORE1</b>, [Active Mode, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM0_LDO_VCORE0</b>, [LMP0, LDO, VCORE0]</li>
<li><b>PCM_LPM0_LDO_VCORE1</b>, [LMP0, LDO, VCORE1]</li>
<li><b>PCM_LPM0_DCDC_VCORE0</b>, [LMP0, DCDC, VCORE0]</li>
<li><b>PCM_LPM0_DCDC_VCORE1</b>, [LMP0, DCDC, VCORE1]</li>
<li><b>PCM_LPM0_LF_VCORE0</b>, [LMP0, Low Frequency, VCORE0]</li>
<li><b>PCM_LPM0_LF_VCORE1</b>, [LMP0, Low Frequency, VCORE1]</li>
<li><b>PCM_LPM3</b>, [LPM3]</li>
<li><b>PCM_LPM35_VCORE0</b>, [LPM3.5 VCORE 0]</li>
<li><b>PCM_LPM45</b>, [LPM4.5]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if power state change was initiated, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="gaf8a4f38b56ffdfa166f74de92b64ea08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_shutdownDevice </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shutdownMode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM3.5/LPM4.5 mode.</p>
<p>Refer to the device specific data sheet for specifics about shutdown modes.</p>
<p>The following events will cause a wake up from LPM3.5 mode:</p><ul>
<li>Device reset</li>
<li>External reset RST</li>
<li>Enabled RTC, WDT, and wake-up I/O only interrupt events</li>
</ul>
<p>The following events will cause a wake up from the LPM4.5 mode:</p><ul>
<li>Device reset</li>
<li>External reset RST</li>
<li>Wake-up I/O only interrupt events</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shutdownMode</td><td>Specific mode to go to. Valid values are:<ul>
<li><b>PCM_LPM35_VCORE0</b> </li>
<li><b>PCM_LPM45</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if shutdown state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="debug_8h.html#a28301f76c53b643912da7c538f74e2c6">ASSERT</a>, <a class="el" href="cpu_8h.html#a4731ceaa6bbd2ea91f04553700de59a8">CPU_wfi()</a>, <a class="el" href="group__pcm__api.html#ga99147e526657c3b835d9761759ff08ea">PCM_KEY</a>, <a class="el" href="group__pcm__api.html#gae3369099804e8ec1bfbdb396fbdab5f3">PCM_LPM45</a>, <a class="el" href="group__pcm__api.html#gac091b7ed755f0e16ddeba7d07b79c082">PCM_SHUTDOWN_COMPLETE</a>, and <a class="el" href="group__pcm__api.html#ga1536275cd1b086070caf9219948ebada">PCM_SHUTDOWN_PARTIAL</a>.</p>

</div>
</div>
<a class="anchor" id="gaffe310d00db05c52931b714da4c11b7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM0 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM0.</p>
<p>Refer to the device specific data sheet for specifics about low power modes.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="cpu_8h.html#a4731ceaa6bbd2ea91f04553700de59a8">CPU_wfi()</a>.</p>

<p>Referenced by <a class="el" href="group__pcm__api.html#gaf1d3320b552e378c333c37fad34517a3">PCM_gotoLPM0InterruptSafe()</a>.</p>

</div>
</div>
<a class="anchor" id="ga629a4ca61ca8813a231250057d426885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM3 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM3</p>
<p>Refer to the device specific data sheet for specifics about low power modes. Note that since LPM3 cannot be entered from a DCDC power modes, the power mode is first switched to LDO operation (if in DCDC mode), the deep sleep is entered, and the DCDC mode is restored on wake up.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="cpu_8h.html#a4731ceaa6bbd2ea91f04553700de59a8">CPU_wfi()</a>, <a class="el" href="group__pcm__api.html#ga2110b687d5cef1fae56323db2f747795">PCM_DCDC_MODE</a>, <a class="el" href="group__pcm__api.html#ga98797f17f6b52e66b8eb42b86f0c2e1d">PCM_getPowerMode()</a>, <a class="el" href="group__pcm__api.html#ga0fd3e28f2cf736397d7849b13e29e086">PCM_getPowerState()</a>, <a class="el" href="group__pcm__api.html#ga99147e526657c3b835d9761759ff08ea">PCM_KEY</a>, <a class="el" href="group__pcm__api.html#gaea3880d9ab27db9004ac4f9b991c2c1f">PCM_LDO_MODE</a>, <a class="el" href="group__pcm__api.html#gac177f4b7ecfce7200a95b5a6bacbf89a">PCM_LF_MODE</a>, <a class="el" href="group__pcm__api.html#ga5bbba40f896f89b792b78f4b54b0078d">PCM_setPowerMode()</a>, and <a class="el" href="group__pcm__api.html#gadcfe9e81af9f912ad010dea02a84e1dd">PCM_setPowerState()</a>.</p>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga3bf9fd4192110e273db7648dae87de3d">PCM_gotoLPM3InterruptSafe()</a>, and <a class="el" href="group__pcm__api.html#gacd8029aa4c1db3892bbe3e93af840b31">PCM_gotoLPM4()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1d3320b552e378c333c37fad34517a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM0InterruptSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM0 while maintaining a safe interrupt handling mentality. This function is meant to be used in situations where the user wants to go to sleep, however does not want to go to "miss" any interrupts due to the fact that going to LPM0 is not an atomic operation. This function will modify the PRIMASK and on exit of the program the master interrupts will be disabled.</p>
<p>Refer to the device specific data sheet for specifics about low power modes.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="group__interrupt__api.html#gaca7fa29bb09eba271bda9b1465ac3780">Interrupt_disableMaster()</a>, <a class="el" href="group__interrupt__api.html#ga35c0ad777367b937414e7bfc09e0788c">Interrupt_enableMaster()</a>, and <a class="el" href="group__pcm__api.html#gaffe310d00db05c52931b714da4c11b7d">PCM_gotoLPM0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3bf9fd4192110e273db7648dae87de3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM3InterruptSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM3 while maintaining a safe interrupt handling mentality. This function is meant to be used in situations where the user wants to go to LPM3, however does not want to go to "miss" any interrupts due to the fact that going to LPM3 is not an atomic operation. This function will modify the PRIMASK and on exit of the program the master interrupts will be disabled.</p>
<p>Refer to the device specific data sheet for specifics about low power modes. Note that since LPM3 cannot be entered from a DCDC power modes, the power mode is first switched to LDO operation (if in DCDC mode), the deep sleep is entered, and the DCDC mode is restored on wake up.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="group__interrupt__api.html#gaca7fa29bb09eba271bda9b1465ac3780">Interrupt_disableMaster()</a>, <a class="el" href="group__interrupt__api.html#ga35c0ad777367b937414e7bfc09e0788c">Interrupt_enableMaster()</a>, and <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>.</p>

</div>
</div>
<a class="anchor" id="gacd8029aa4c1db3892bbe3e93af840b31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM4 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM4. LPM4 is the exact same with LPM3, just with RTC_C and WDT_A disabled. When waking up, RTC_C and WDT_A will remain disabled until reconfigured by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="group__pcm__api.html#ga629a4ca61ca8813a231250057d426885">PCM_gotoLPM3()</a>, <a class="el" href="group__rtc__api.html#ga11ae196636f0afaa355403d6349e9599">RTC_C_holdClock()</a>, and <a class="el" href="group__wdt__api.html#ga67191ac5feea0b7285d8fc853effdfb6">WDT_A_holdTimer()</a>.</p>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga2e450f968451a50c570baa972e37250a">PCM_gotoLPM4InterruptSafe()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e450f968451a50c570baa972e37250a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PCM_gotoLPM4InterruptSafe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transitions the device into LPM4 while maintaining a safe interrupt handling mentality. This function is meant to be used in situations where the user wants to go to LPM4, however does not want to go to "miss" any interrupts due to the fact that going to LPM4 is not an atomic operation. This function will modify the PRIMASK and on exit of the program the master interrupts will be disabled.</p>
<p>Refer to the device specific data sheet for specifics about low power modes. Note that since LPM3 cannot be entered from a DCDC power modes, the power mode is first switched to LDO operation (if in DCDC mode), the deep sleep is entered, and the DCDC mode is restored on wake up.</p>
<dl class="section return"><dt>Returns</dt><dd>false if sleep state cannot be entered, true otherwise. </dd></dl>

<p>References <a class="el" href="group__interrupt__api.html#gaca7fa29bb09eba271bda9b1465ac3780">Interrupt_disableMaster()</a>, <a class="el" href="group__interrupt__api.html#ga35c0ad777367b937414e7bfc09e0788c">Interrupt_enableMaster()</a>, and <a class="el" href="group__pcm__api.html#gacd8029aa4c1db3892bbe3e93af840b31">PCM_gotoLPM4()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4787884be1ce9ed19008fad506d3036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_enableRudeMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables "rude mode" entry into LPM3 and shutdown modes. With this mode enabled, an entry into shutdown or LPM3 will occur even if there are clock systems active. The system will forcibly turn off all clock/systems when going into these modes.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>References <a class="el" href="group__pcm__api.html#ga99147e526657c3b835d9761759ff08ea">PCM_KEY</a>.</p>

</div>
</div>
<a class="anchor" id="ga022c681cdc82a9a729d4c6491fa04fdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_disableRudeMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables "rude mode" entry into LPM3 and shutdown modes. With this mode disabled, an entry into shutdown or LPM3 will wait for any active clock requests to free up before going into LPM3 or shutdown.</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

<p>References <a class="el" href="group__pcm__api.html#ga99147e526657c3b835d9761759ff08ea">PCM_KEY</a>.</p>

</div>
</div>
<a class="anchor" id="gaa13b8e1cdcad429be17abf93ef32b55e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables individual power control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables the indicated power control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga57c6fa2c61a09135ec4ad2467b465ac2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables individual power control interrupt sources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be enabled. Must be a logical OR of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p>This function disables the indicated power control interrupt sources. Only the sources that are enabled can be reflected to the processor interrupt; disabled sources have no effect on the processor.</p>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga13480f488469c23521b1c583c6869b37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PCM_getInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

<p>Referenced by <a class="el" href="group__pcm__api.html#ga2e666dad597a14a2ed14220bf1045862">PCM_getEnabledInterruptStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e666dad597a14a2ed14220bf1045862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t PCM_getEnabledInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current interrupt status masked with the enabled interrupts. This function is useful to call in ISRs to get a list of pending interrupts that are actually enabled and could have caused the ISR.</p>
<dl class="section return"><dt>Returns</dt><dd>The current interrupt status, enumerated as a bit field of:<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available. </dd></dl>

<p>References <a class="el" href="group__pcm__api.html#ga13480f488469c23521b1c583c6869b37">PCM_getInterruptStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="ga63181a0fc0044f9db7e5666706a51b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_clearInterruptFlag </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears power system interrupt sources.</p>
<p>The specified power system interrupt sources are cleared, so that they no longer assert. This function must be called in the interrupt handler to keep it from being called again immediately upon exit.</p>
<dl class="section note"><dt>Note</dt><dd>Because there is a write buffer in the Cortex-M processor, it may take several clock cycles before the interrupt source is actually cleared. Therefore, it is recommended that the interrupt source be cleared early in the interrupt handler (as opposed to the very last action) to avoid returning from the interrupt handler before the interrupt source is actually cleared. Failure to do so may result in the interrupt handler being immediately reentered (because the interrupt controller still sees the interrupt source asserted).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>is a bit mask of the interrupt sources to be cleared. Must be a logical OR of<ul>
<li><b>PCM_DCDCERROR</b>,</li>
<li><b>PCM_AM_INVALIDTRANSITION</b>,</li>
<li><b>PCM_SM_INVALIDCLOCK</b>,</li>
<li><b>PCM_SM_INVALIDTRANSITION</b> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The interrupt sources vary based on the part in use. Please consult the data sheet for the part you are using to determine which interrupt sources are available.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9994d27c2640ad8f86173f0ec36a383d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_registerInterrupt </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>intHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers an interrupt handler for the power system interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intHandler</td><td>is a pointer to the function to be called when the power system interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the handler to be called when a clock system interrupt occurs. This function enables the global interrupt in the interrupt controller; specific PCM interrupts must be enabled via <a class="el" href="group__pcm__api.html#gaa13b8e1cdcad429be17abf93ef32b55e">PCM_enableInterrupt()</a>. It is the interrupt handler's responsibility to clear the interrupt source via <a class="el" href="group__pcm__api.html#ga63181a0fc0044f9db7e5666706a51b4d">PCM_clearInterruptFlag</a> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__interrupt__api.html#ga9024d379a7a794d5faaaae89efbf2d41">INT_PCM</a>, <a class="el" href="group__interrupt__api.html#ga8d4a0f9306680b46de147ca4c89ebf59">Interrupt_enableInterrupt()</a>, and <a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a6b73614bd5c9fe03650563624ffcc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PCM_unregisterInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregisters the interrupt handler for the power system.</p>
<p>This function unregisters the handler to be called when a power system interrupt occurs. This function also masks off the interrupt in the interrupt controller so that the interrupt handler no longer is called.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__interrupt__api.html#gae2a33716d48a45c7c719304d185c6620">Interrupt_registerInterrupt()</a> for important information about registering interrupt handlers.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

<p>References <a class="el" href="group__interrupt__api.html#ga9024d379a7a794d5faaaae89efbf2d41">INT_PCM</a>, <a class="el" href="group__interrupt__api.html#gae2400abe33e456798c5d9efed5f8c341">Interrupt_disableInterrupt()</a>, and <a class="el" href="group__interrupt__api.html#ga7e1475da4dd9998c5ab9a96f0be03d36">Interrupt_unregisterInterrupt()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr size="1" /><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
