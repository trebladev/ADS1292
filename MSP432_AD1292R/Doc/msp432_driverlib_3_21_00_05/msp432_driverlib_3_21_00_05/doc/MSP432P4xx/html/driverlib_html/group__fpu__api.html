<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FPU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FPU</div>  </div>
</div><!--header-->
<div class="contents">

<p>ARM's Floating Point Unit module.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8c4806f80aed73ebc0842841ed5599d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga8c4806f80aed73ebc0842841ed5599d6">FPU_HALF_IEEE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga8c4806f80aed73ebc0842841ed5599d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab13c5f2956df73c35358d7ec517265b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gab13c5f2956df73c35358d7ec517265b5">FPU_HALF_ALTERNATE</a>&#160;&#160;&#160;0x04000000</td></tr>
<tr class="separator:gab13c5f2956df73c35358d7ec517265b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bfaacdcca131769d9ed7b53b53b10b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga16bfaacdcca131769d9ed7b53b53b10b">FPU_NAN_PROPAGATE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga16bfaacdcca131769d9ed7b53b53b10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0cd5ea318a050eed356e40894e0537"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga8b0cd5ea318a050eed356e40894e0537">FPU_NAN_DEFAULT</a>&#160;&#160;&#160;0x02000000</td></tr>
<tr class="separator:ga8b0cd5ea318a050eed356e40894e0537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58d6cfcb70a0994ae7f8b420a16812d4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga58d6cfcb70a0994ae7f8b420a16812d4">FPU_FLUSH_TO_ZERO_DIS</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga58d6cfcb70a0994ae7f8b420a16812d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95462d4ecb5f44361c48755b1f3d925"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gaa95462d4ecb5f44361c48755b1f3d925">FPU_FLUSH_TO_ZERO_EN</a>&#160;&#160;&#160;0x01000000</td></tr>
<tr class="separator:gaa95462d4ecb5f44361c48755b1f3d925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494226dd413196403c15acb1181e84fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga494226dd413196403c15acb1181e84fd">FPU_ROUND_NEAREST</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:ga494226dd413196403c15acb1181e84fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64a8179f61c66f1c39ed21d2b78205b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga64a8179f61c66f1c39ed21d2b78205b9">FPU_ROUND_POS_INF</a>&#160;&#160;&#160;0x00400000</td></tr>
<tr class="separator:ga64a8179f61c66f1c39ed21d2b78205b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec7d336d7378097e1d29966dfa1906af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gaec7d336d7378097e1d29966dfa1906af">FPU_ROUND_NEG_INF</a>&#160;&#160;&#160;0x00800000</td></tr>
<tr class="separator:gaec7d336d7378097e1d29966dfa1906af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdc50fb1f813a81f47fac15843f239c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gafdc50fb1f813a81f47fac15843f239c1">FPU_ROUND_ZERO</a>&#160;&#160;&#160;0x00c00000</td></tr>
<tr class="separator:gafdc50fb1f813a81f47fac15843f239c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga67d49427a95e0ec2f386a4829a7a97cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga67d49427a95e0ec2f386a4829a7a97cb">FPU_enableModule</a> (void)</td></tr>
<tr class="separator:ga67d49427a95e0ec2f386a4829a7a97cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c7caaefbb6595d8f27065ce1d0fb7f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga6c7caaefbb6595d8f27065ce1d0fb7f9">FPU_disableModule</a> (void)</td></tr>
<tr class="separator:ga6c7caaefbb6595d8f27065ce1d0fb7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga595ad279b687279b812fbd047294fbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga595ad279b687279b812fbd047294fbba">FPU_enableStacking</a> (void)</td></tr>
<tr class="separator:ga595ad279b687279b812fbd047294fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5228bc86f3b74965400fb4dbbc2034"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gafc5228bc86f3b74965400fb4dbbc2034">FPU_enableLazyStacking</a> (void)</td></tr>
<tr class="separator:gafc5228bc86f3b74965400fb4dbbc2034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf52dc82811e5c1fa39b679d4a3c62106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gaf52dc82811e5c1fa39b679d4a3c62106">FPU_disableStacking</a> (void)</td></tr>
<tr class="separator:gaf52dc82811e5c1fa39b679d4a3c62106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga044f69ac5f795d2c6aefe8ac0d81bf35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga044f69ac5f795d2c6aefe8ac0d81bf35">FPU_setHalfPrecisionMode</a> (uint32_t mode)</td></tr>
<tr class="separator:ga044f69ac5f795d2c6aefe8ac0d81bf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84fbef1890aaf2c2213b9ace1f0c3150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga84fbef1890aaf2c2213b9ace1f0c3150">FPU_setNaNMode</a> (uint32_t mode)</td></tr>
<tr class="separator:ga84fbef1890aaf2c2213b9ace1f0c3150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2846d046eeb1dc2c55209d8ff353de21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#ga2846d046eeb1dc2c55209d8ff353de21">FPU_setFlushToZeroMode</a> (uint32_t mode)</td></tr>
<tr class="separator:ga2846d046eeb1dc2c55209d8ff353de21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4e5e0b5b6f1cfc49daea523aab0775e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpu__api.html#gae4e5e0b5b6f1cfc49daea523aab0775e">FPU_setRoundingMode</a> (uint32_t mode)</td></tr>
<tr class="separator:gae4e5e0b5b6f1cfc49daea523aab0775e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>ARM's Floating Point Unit module. </p>
<p> 
<hr>
<h1> FPU Module Operation </h1>
<hr>
 The floating-point unit (FPU) driver provides methods for manipulating the behavior of the floating-point unit in the Cortex-M processor. By default, the floating-point is disabled and must be enabled prior to the execution of any floating-point instructions. If a floating-point instruction is executed when the floating-point unit is disabled, a NOCP usage fault is generated. This feature can be used by an RTOS, for example, to keep track of which tasks actually use the floating-point unit, and therefore only perform floating-point context save/restore on task switches that involve those tasks.</p>
<p>There are three methods of handling the floating-point context when the processor executes an interrupt handler: it can do nothing with the floating-point context, it can always save the floating-point context, or it can perform a lazy save/restore of the floating-point context. If nothing is done with the floating-point context, the interrupt stack frame is identical to a Cortex-M processor that does not have a floating-point unit, containing only the volatile registers of the integer unit. This method is useful for applications where the floating-point unit is used by the main thread of execution, but not in any of the interrupt handlers. By not saving the floating-point context, stack usage is reduced and interrupt latency is kept to a minimum.</p>
<p>Alternatively, the floating-point context can always be saved onto the stack. This method allows floating-point operations to be performed inside interrupt handlers without any special precautions, at the expense of increased stack usage (for the floating-point context) and increased interrupt latency (due to the additional writes to the stack). The advantage to this method is that the stack frame always contains the floating-point context when inside an interrupt handler.</p>
<p>The default handling of the floating-point context is to perform a lazy save/restore. When an interrupt is taken, space is reserved on the stack for the floating-point context but the context is not written. This method keeps the interrupt latency to a minimum because only the integer state is written to the stack. Then, if a floating-point instruction is executed from within the interrupt handler, the floating-point context is written to the stack prior to the execution of the floating-point instruction. Finally, upon return from the interrupt, the floating-point context is restored from the stack only if it was written. Using lazy save/restore provides a blend between fast interrupt response and the ability to use floating-point instructions in the interrupt handler.</p>
<p>The floating-point unit can generate an interrupt when one of several exceptions occur. The exceptions are underflow, overflow, divide by zero, invalid operation, input denormal, and inexact exception. The application can optionally choose to enable one or more of these interrupts and use the interrupt handler to decide upon a course of action to be taken in each case.</p>
<p>The behavior of the floating-point unit can also be adjusted, specifying the format of half-precision floating-point values, the handle of NaN values, the flush-to-zero mode (which sacrifices full IEEE compliance for execution speed), and the rounding mode for results.</p>
<p> 
<hr>
<h2> Programming Example </h2>
<hr>
 The DriverLib package contains a variety of different code examples that demonstrate the usage of the FPU module. These code examples are accessible under the examples/ folder of the MSPWare release as well as through TI Resource Explorer if using Code Composer Studio. These code examples provide a comprehensive list of use cases as well as practical applications involving each module.</p>
<p>Below is a very brief example of floating point operation. While the compiler will usually enable the floating point unit by default, when executing floating point operations it is important to make sure that the coprocessor is enabled (otherwise a system fault will occur).</p>
<div class="fragment"><div class="line">    <span class="comment">/* Enabling FPU for DCO Frequency calculation */</span></div>
<div class="line">    <a class="code" href="rom__map_8h.html#ad889ca345c2f7a4e9d985a0c93fdd6f4">MAP_FPU_enableModule</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="comment">/* Setting the DCO Frequency to a non-standard 8.33MHz */</span></div>
<div class="line">    <a class="code" href="rom__map_8h.html#a99ea793d5c40b45e1ac89b7ac21099c4">MAP_CS_setDCOFrequency</a>(8330000);</div>
</div><!-- fragment --><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga8c4806f80aed73ebc0842841ed5599d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_HALF_IEEE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gab13c5f2956df73c35358d7ec517265b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_HALF_ALTERNATE&#160;&#160;&#160;0x04000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga16bfaacdcca131769d9ed7b53b53b10b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_NAN_PROPAGATE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b0cd5ea318a050eed356e40894e0537"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_NAN_DEFAULT&#160;&#160;&#160;0x02000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga58d6cfcb70a0994ae7f8b420a16812d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_FLUSH_TO_ZERO_DIS&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa95462d4ecb5f44361c48755b1f3d925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_FLUSH_TO_ZERO_EN&#160;&#160;&#160;0x01000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga494226dd413196403c15acb1181e84fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_ROUND_NEAREST&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga64a8179f61c66f1c39ed21d2b78205b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_ROUND_POS_INF&#160;&#160;&#160;0x00400000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gaec7d336d7378097e1d29966dfa1906af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_ROUND_NEG_INF&#160;&#160;&#160;0x00800000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="gafdc50fb1f813a81f47fac15843f239c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FPU_ROUND_ZERO&#160;&#160;&#160;0x00c00000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga67d49427a95e0ec2f386a4829a7a97cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_enableModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the floating-point unit.</p>
<p>This function enables the floating-point unit, allowing the floating-point instructions to be executed. This function must be called prior to performing any hardware floating-point operations; failure to do so results in a NOCP usage fault.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6c7caaefbb6595d8f27065ce1d0fb7f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_disableModule </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the floating-point unit.</p>
<p>This function disables the floating-point unit, preventing floating-point instructions from executing (generating a NOCP usage fault instead).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga595ad279b687279b812fbd047294fbba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_enableStacking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the stacking of floating-point registers.</p>
<p>This function enables the stacking of floating-point registers s0-s15 when an interrupt is handled. When enabled, space is reserved on the stack for the floating-point context and the floating-point state is saved into this stack space. Upon return from the interrupt, the floating-point context is restored.</p>
<p>If the floating-point registers are not stacked, floating-point instructions cannot be safely executed in an interrupt handler because the values of s0-s15 are not likely to be preserved for the interrupted code. On the other hand, stacking the floating-point registers increases the stacking operation from 8 words to 26 words, also increasing the interrupt response latency.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gafc5228bc86f3b74965400fb4dbbc2034"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_enableLazyStacking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the lazy stacking of floating-point registers.</p>
<p>This function enables the lazy stacking of floating-point registers s0-s15 when an interrupt is handled. When lazy stacking is enabled, space is reserved on the stack for the floating-point context, but the floating-point state is not saved. If a floating-point instruction is executed from within the interrupt context, the floating-point context is first saved into the space reserved on the stack. On completion of the interrupt handler, the floating-point context is only restored if it was saved (as the result of executing a floating-point instruction).</p>
<p>This method provides a compromise between fast interrupt response (because the floating-point state is not saved on interrupt entry) and the ability to use floating-point in interrupt handlers (because the floating-point state is saved if floating-point instructions are used).</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf52dc82811e5c1fa39b679d4a3c62106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_disableStacking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the stacking of floating-point registers.</p>
<p>This function disables the stacking of floating-point registers s0-s15 when an interrupt is handled. When floating-point context stacking is disabled, floating-point operations performed in an interrupt handler destroy the floating-point context of the main thread of execution.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga044f69ac5f795d2c6aefe8ac0d81bf35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_setHalfPrecisionMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the format of half-precision floating-point values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is the format for half-precision floating-point value, which is either <b>FPU_HALF_IEEE</b> or <b>FPU_HALF_ALTERNATE</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects between the IEEE half-precision floating-point representation and the Cortex-M processor alternative representation. The alternative representation has a larger range but does not have a way to encode infinity (positive or negative) or NaN (quiet or signalling). The default setting is the IEEE format.</p>
<dl class="section note"><dt>Note</dt><dd>Unless this function is called prior to executing any floating-point instructions, the default mode is used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga84fbef1890aaf2c2213b9ace1f0c3150"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_setNaNMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the NaN mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is the mode for NaN results; which is either <b>FPU_NAN_PROPAGATE</b> or <b>FPU_NAN_DEFAULT</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the handling of NaN results during floating-point computations. NaNs can either propagate (the default), or they can return the default NaN.</p>
<dl class="section note"><dt>Note</dt><dd>Unless this function is called prior to executing any floating-point instructions, the default mode is used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2846d046eeb1dc2c55209d8ff353de21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_setFlushToZeroMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the flush-to-zero mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is the flush-to-zero mode; which is either <b>FPU_FLUSH_TO_ZERO_DIS</b> or <b>FPU_FLUSH_TO_ZERO_EN</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables or disables the flush-to-zero mode of the floating-point unit. When disabled (the default), the floating-point unit is fully IEEE compliant. When enabled, values close to zero are treated as zero, greatly improving the execution speed at the expense of some accuracy (as well as IEEE compliance).</p>
<dl class="section note"><dt>Note</dt><dd>Unless this function is called prior to executing any floating-point instructions, the default mode is used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gae4e5e0b5b6f1cfc49daea523aab0775e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void FPU_setRoundingMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the rounding mode for floating-point results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>is the rounding mode.</td></tr>
  </table>
  </dd>
</dl>
<p>This function selects the rounding mode for floating-point results. After a floating-point operation, the result is rounded toward the specified value. The default mode is <b>FPU_ROUND_NEAREST</b>.</p>
<p>The following rounding modes are available (as specified by <em>mode</em>):</p>
<ul>
<li><b>FPU_ROUND_NEAREST</b> - round toward the nearest value</li>
<li><b>FPU_ROUND_POS_INF</b> - round toward positive infinity</li>
<li><b>FPU_ROUND_NEG_INF</b> - round toward negative infinity</li>
<li><b>FPU_ROUND_ZERO</b> - round toward zero</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Unless this function is called prior to executing any floating-point instructions, the default mode is used.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1" /><small>
Copyright  2016, Texas Instruments Incorporated</small>
</body>
</html>
